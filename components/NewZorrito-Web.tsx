/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/NewZorrito-Web.glb --typescript 
*/

import React, { useEffect, useRef } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'
import * as THREE from 'three'
import { GLTF } from 'three-stdlib'

type GLTFResult = GLTF & {
  nodes: {
    Retopo_Cuerpo: THREE.Mesh
    Retopo_Capa: THREE.Mesh
    Retopo_ojos: THREE.Mesh
    Retopo_Accesorio: THREE.Mesh
  }
  materials: {
    Material: THREE.MeshStandardMaterial
    ['Material.001']: THREE.MeshStandardMaterial
    ['Material.003']: THREE.MeshStandardMaterial
    ['Material.002']: THREE.MeshStandardMaterial
  }
}

export function Model(props: React.ComponentProps<'group'>) {
  const group = React.useRef<THREE.Group>(null)
  const { nodes, materials, animations } = useGLTF('/models/NewZorrito-Web.glb') as unknown as GLTFResult
  const { actions, names } = useAnimations(animations, group)
  const { viewport } = useThree()

  // Store mouse position normalized to [-1, 1]
  const mouse = useRef({ x: 0, y: 0 })
  // Smoothed rotation targets
  const targetRotation = useRef({ x: 0, y: 0 })

  // Track mouse position via pointer events on the canvas
  useEffect(() => {
    const handlePointerMove = (e: PointerEvent) => {
      // Normalize mouse to [-1, 1] relative to viewport center
      mouse.current.x = (e.clientX / window.innerWidth) * 2 - 1
      mouse.current.y = -(e.clientY / window.innerHeight) * 2 + 1
    }

    window.addEventListener('pointermove', handlePointerMove)
    return () => window.removeEventListener('pointermove', handlePointerMove)
  }, [])

  // Autoplay the first animation found
  useEffect(() => {
    if (names.length > 0) {
      actions[names[0]]?.reset().fadeIn(0.5).play()
    }
  }, [actions, names])

  useFrame((state) => {
    const t = state.clock.getElapsedTime()
    if (!group.current) return

    // --- Mouse-following rotation ---
    // Base rotation (slightly angled like the original -PI/6)
    const baseRotationY = -Math.PI / 6

    // Mouse influence: fox looks toward cursor
    // X-axis (horizontal mouse) → Y rotation (left/right look)
    // Y-axis (vertical mouse) → X rotation (up/down tilt), very subtle
    targetRotation.current.y = baseRotationY + mouse.current.x * 0.4
    targetRotation.current.x = mouse.current.y * -0.15

    // Smooth interpolation (lerp) for organic feel
    group.current.rotation.y += (targetRotation.current.y - group.current.rotation.y) * 0.05
    group.current.rotation.x += (targetRotation.current.x - group.current.rotation.x) * 0.05

    // --- Floating effect (preserved) ---
    group.current.position.y = -0.2 + Math.sin(t * 1) * 0.08

    // --- Subtle sway: fox leans slightly into the direction it's looking ---
    const targetZ = mouse.current.x * 0.05
    group.current.rotation.z += (targetZ - group.current.rotation.z) * 0.03
  })

  return (
    <group ref={group} {...props} dispose={null}>
      <mesh
        geometry={nodes.Retopo_Cuerpo.geometry}
        material={materials.Material}
      />
      <mesh
        geometry={nodes.Retopo_Capa.geometry}
        material={materials['Material.001']}
      />
      <mesh
        geometry={nodes.Retopo_ojos.geometry}
        material={materials['Material.003']}
      />
      <mesh
        geometry={nodes.Retopo_Accesorio.geometry}
        material={materials['Material.002']}
      />
    </group>
  )
}

useGLTF.preload('/models/NewZorrito-Web.glb')